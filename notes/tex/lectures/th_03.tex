\section{Modellazione dei programmi}
L'obiettivo dell'analisi statica è certificare che un programma sia sicuro
rispetto a determinati errori, come ad esempio la divisione per zero.

\subsection{Poset nell'analisi statica}

L'idea fondamentale è calcolare i possibili valori che una variabile può
assumere in ogni punto del programma, considerando tutte le possibili
esecuzioni.
Per fare questo è possibile utilizzare i reticoli (Definizione
\Cref{def:lattice}).

\begin{esempio}{Esempio di reticolo su un programma}{}
Considerando il programma seguente:

\begin{verbatim}
1: i = read ();
2 if ( i != 0 )
3   j = 5 / i ;
4 else
5   j = 0;
6 return;
\end{verbatim}

e definendo il reticolo dei valori interi come $\langle
\mathcal{P}(\mathbb{Z}), \subseteq, \cup, \cap \rangle$ è possibile
calcolare i possibili valori delle variabili $i$ e $j$ in ogni punto
del programma.

\medskip

\begin{center}
\begin{tabular}{|c|l|}
  \hline
  \textbf{Program point} & \textbf{Valori} \\
  \hline
  \hline
  1 & $i = \{\}, \ j = \{\}$ \\
  \hline
  2 & $i = \mathbb{Z}, \ j = \{\}$ \\
  \hline
  3 & $i = \mathbb{Z} \setminus \{0\}, \ j = \{5 / i \}$ \\
  \hline
  5 & $i = \{0\}, \ j = \{0\}$ \\
  \hline
  6 & $i = \mathbb{Z}, \ j = \{-5, -2, -1, 0, 1, 2, 5 \}$ \\
  \hline
\end{tabular}
\end{center}

Per ottenere i valori di $j$ al punto $6$, è stato necessario calcolare
l'unione dei valori di $j$ provenienti dai punti $3$ e $5$, utilizzando
l'operazione di least upper bound (operazione di join, unione insiemistica
in questo caso).

Per ottenere i valori di $i$ al punto $2$, è stato necessario considerare
che la funzione \texttt{read()} può restituire qualsiasi valore intero.
Dopo di che tramite un'operazione di ``filtro'' $filter(i != 0)$ è
possibile restringere i valori di $i$ per entrare nel ramo vero dell'if.
Per il calcolo del punto $3$, invece è stato necessario applicare l'operazione
di intersezione tra i valori di $i$ al punto $2$ e il filtro $filter(x \neq 0)$
per ottenere i valori di $i$ validi per quel ramo.


Ipotizzando che la funzione \texttt{read()} possa restituire valori interi in
$\{ -1, 0, 1 \}$, è possibile riscrivere il codice del programma di esempio
come:
\begin{verbatim}
1: i = {-1, 0, 1} ;
2 if ( i != 0 )
3   j = 5 / i ;
4 else
5   j = 0;
6 return;
\end{verbatim}
Di conseguenza i valori delle variabili in ogni punto del programma
diventano:

\medskip

\begin{center}
\begin{tabular}{|c|l|}
  \hline
  \textbf{Program point} & \textbf{Valori} \\
  \hline
  \hline
  1 & $i = \{\}, \ j = \{\}$ \\
  \hline
  2 & $i = [-1, 1], \ j = \{\}$ \\
  \hline
  3 & $i = [-1, -1] \cup [1, 1], \ j = [ -5, 5 ]$ \\
  \hline
  5 & $i = [0, 0], \ j = [0, 0]$ \\
  \hline
  6 & $i = [-1, 1], \ j = [-5, 5]$ \\
  \hline
\end{tabular}
\end{center}
\end{esempio}


\subsection{Punti fissi}
Quando il programma contiene dei cicli (come \texttt{while}), il numero di
esecuzioni possibili diventa arbitrario o infinito.
Per analizzare queste strutture, utilizziamo il concetto di punto fisso
(Definizione \Cref{def:fixpoint}).
L'analisi procede iterativamente accumulando informazioni
(tramite il Join $\cup$) finché lo stato non si stabilizza.

\begin{esempio}{Analisi di un ciclo su dominio infinito (Non terminazione)}{fixpoint_infinite}

Considerando il programma seguente che presenta un ciclo infinito che
incrementa un contatore:

\begin{verbatim}
1: i = 0;
2: while (?)
3:   i++;
4: ...
\end{verbatim}

Utilizzando il reticolo $\langle \mathcal{P}(\mathbb{Z}), \subseteq, \cup, \cap \rangle$,
è possibile calcolare i valori di $i$ al punto $2$ (l'ingresso del ciclo).
Lo stato al punto $2$ è definito come l'unione del valore iniziale (da 1) e
del valore di ritorno dal ciclo (da 3):
\[ Val(2) = \{0\} \cup (Val(3) + 1) \]

Passo passo:

\medskip

\begin{center}
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|l|l|}
  \hline
  \textbf{Iterazione} & \textbf{Valori al Punto 2} & \textbf{Valori al Punto 3} \\
  \hline
  \hline
  0 & $\emptyset$ & $\emptyset$ \\
  \hline
  1 & $\{0\}$ & $\emptyset$ \\
  \hline
  2 & $\{0\}$ & $\{0\}$ \\
  \hline
  3 & $\{0\} \cup \{0+1\} = \{0, 1\}$ & $\{0\}$ \\
  \hline
  4 & $\{0, 1\}$ & $\{0, 1\}$ \\
  \hline
  5 & $\{0, 1\} \cup \{1+1\} = \{0, 1, 2\}$ & $\{0, 1\}$ \\
  \hline
  \dots & \dots & \dots \\
  \hline
\end{tabular}
\end{center}

Si nota che l'insieme continua a crescere ($ \{0, 1, 2, 3, \dots\} $) e,
poiché il reticolo $\mathcal{P}(\mathbb{Z})$ ha altezza infinita, l'algoritmo
non raggiunge mai un punto fisso in tempo finito.
\end{esempio}

\subsection{IMP}

\subsubsection{Semantica concreta}


\subsection{Semantica delle tracce}